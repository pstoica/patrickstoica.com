---
import Sketch from "@/layouts/Sketch.astro";
import SettingsPanel from "@/components/SettingsPanel";
---

<Sketch
  title="Sense Weave ðŸ§¶"
  backgroundColor="bg-white dark:bg-black"
  maxWidth=""
  aspectRatio=""
>
  <div id="sketch-container" class="w-full h-lvh"></div>
  <div
    id="button-container"
    class="fixed bottom-0 left-0 w-full flex justify-between items-center bg-white dark:bg-black border-t border-gray-200 dark:border-gray-800 z-10"
  >
    <button
      id="clear-button"
      class="w-1/2 text-gray-800 dark:text-gray-200 py-2 font-mono text-lg lowercase hover:bg-gray-100 dark:hover:bg-gray-900 transition-colors"
    >
      Clear
    </button>
    <button
      id="settings-button"
      class="w-1/2 text-gray-800 dark:text-gray-200 py-2 font-mono text-lg border-l border-gray-200 dark:border-gray-800 lowercase hover:bg-gray-100 dark:hover:bg-gray-900 transition-colors"
    >
      Settings
    </button>
  </div>
  <div id="settings-panel-container">
    <SettingsPanel client:load />
  </div>
</Sketch>

<script>
  import { colorSchemes, defaultParams } from "@/components/SettingsPanel";
  import p5 from "p5";

  let sketchInstance: p5;
  let params = {
    ...defaultParams,
    colorScheme: Object.values(colorSchemes)[0],
    isDarkMode: document.documentElement.classList.contains("dark"),
  };

  // Global function to update params
  window.updateSketchParams = (newParams) => {
    params = { ...params, ...newParams };
    if ("isDarkMode" in newParams) {
      updateDarkMode(newParams.isDarkMode);
    }
  };

  // Add this global variable
  window.isInteractingWithUI = false;

  function updateDarkMode(isDark: boolean) {
    if (isDark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }

  const sketch = (p: p5) => {
    sketchInstance = p;

    let paths: {
      path: { pos: p5.Vector; time: number }[];
      startTime: number;
      hueOffset: number;
    }[] = [];
    let currentPath: { pos: p5.Vector; time: number }[] = [];
    let currentPathStartTime = 0;
    let isDrawing = false;
    let currentHueOffset = 0;

    let rippleOffset = 0;

    function clearCanvas() {
      if (sketchInstance) {
        sketchInstance.clear();
        sketchInstance.background(255);
        paths = [];
        currentPath = [];
      }
    }

    p.setup = () => {
      const container = document.getElementById("sketch-container");
      p.createCanvas(container!.clientWidth, container!.clientHeight);
      p.colorMode(p.HSB);
      p.background(255);

      // Update event listeners for Clear and Settings buttons
      const clearButton = document.getElementById("clear-button");
      const settingsButton = document.getElementById("settings-button");

      const handleButtonInteraction = (e: Event) => {
        e.preventDefault();
        e.stopPropagation();
        window.isInteractingWithUI = true;
      };

      clearButton?.addEventListener("mousedown", handleButtonInteraction);
      clearButton?.addEventListener("touchstart", handleButtonInteraction);
      settingsButton?.addEventListener("touchstart", handleButtonInteraction);

      const handleClearButton = (e: Event) => {
        e.preventDefault();
        e.stopPropagation();
        clearCanvas();
      };

      clearButton?.addEventListener("click", handleClearButton);
      clearButton?.addEventListener("touchstart", (e) => {
        handleClearButton(e);
        handleButtonInteraction(e);
      });

      const toggleSettings = (e: Event) => {
        e.preventDefault();
        e.stopPropagation();
        const event = new CustomEvent("toggleSettings");
        window.dispatchEvent(event);
      };
      settingsButton?.addEventListener("click", (e) => {
        toggleSettings(e);
        handleButtonInteraction(e);
      });
      settingsButton?.addEventListener("touchstart", (e) => {
        toggleSettings(e);
        handleButtonInteraction(e);
      });

      // Add global event listeners to reset isInteractingWithUI
      window.addEventListener("mouseup", () => {
        window.isInteractingWithUI = false;
      });
      window.addEventListener("touchend", () => {
        window.isInteractingWithUI = false;
      });
    };

    p.draw = () => {
      // Update background color based on dark mode
      p.background(
        document.documentElement.classList.contains("dark") ? 0 : 245
      );

      // Update ripple offset
      rippleOffset += params.rippleSpeed;

      // Clear the canvas and redraw all paths with updated colors and sizes
      paths = paths.filter((path) => path.path.length > 0);
      paths.forEach(({ path, startTime, hueOffset }) =>
        drawPath(path, startTime, hueOffset)
      );
      if (isDrawing) {
        drawPath(currentPath, currentPathStartTime, currentHueOffset);
      }
    };

    const startDrawing = (x: number, y: number) => {
      isDrawing = true;
      currentPath = [];
      currentHueOffset = p.random(360); // Random starting hue for each stroke
      currentPathStartTime = p.millis();
      addPoint(x, y);
    };

    const stopDrawing = () => {
      isDrawing = false;
      if (currentPath.length > 0) {
        paths.push({
          path: currentPath,
          startTime: currentPathStartTime,
          hueOffset: currentHueOffset,
        });
      }
    };

    const addPoint = (x: number, y: number) => {
      if (isDrawing && !window.isInteractingWithUI) {
        const point = p.createVector(x, y);
        if (
          currentPath.length === 0 ||
          p5.Vector.dist(point, currentPath[currentPath.length - 1].pos) >
            params.smoothness
        ) {
          currentPath.push({ pos: point, time: p.millis() });
        }
      }
    };

    // Mouse event handlers
    p.mousePressed = () => {
      if (!window.isInteractingWithUI) {
        startDrawing(p.mouseX, p.mouseY);
      }
      return false;
    };

    p.mouseReleased = () => {
      if (!window.isInteractingWithUI) {
        stopDrawing();
      }
      return false;
    };

    p.mouseDragged = () => {
      if (!window.isInteractingWithUI) {
        addPoint(p.mouseX, p.mouseY);
      }
      return false;
    };

    // Touch event handlers
    p.touchStarted = () => {
      if (!window.isInteractingWithUI && p.touches.length > 0) {
        const touch = p.touches[0] as { x: number; y: number };
        startDrawing(touch.x, touch.y);
      }
      return false;
    };

    p.touchEnded = () => {
      if (!window.isInteractingWithUI) {
        stopDrawing();
      }
      return false;
    };

    p.touchMoved = () => {
      if (!window.isInteractingWithUI && p.touches.length > 0) {
        const touch = p.touches[0] as { x: number; y: number };
        addPoint(touch.x, touch.y);
      }
      return false;
    };

    function drawPath(
      path: { pos: p5.Vector; time: number }[],
      startTime: number,
      hueOffset: number
    ) {
      if (path.length < 2) return;

      p.push();

      let accumulatedLength = 0;
      for (let i = 0; i < path.length; i++) {
        const point = path[i];
        const x = point.pos.x;
        const y = point.pos.y;

        if (i > 0) {
          accumulatedLength += p5.Vector.dist(path[i - 1].pos, point.pos);
        }

        // Calculate the gradient position, allowing for smooth repetition
        const t =
          (accumulatedLength % params.gradientLength) / params.gradientLength;

        // Incorporate baseShiftSpeed to shift colors over time
        const shiftedT = (t + p.frameCount * params.baseShiftSpeed * 0.001) % 1;

        // Interpolate between colors in the colorScheme
        const colorIndex = shiftedT * params.colorScheme.length;
        const colorIndexLow =
          Math.floor(colorIndex) % params.colorScheme.length;
        const colorIndexHigh = (colorIndexLow + 1) % params.colorScheme.length;
        const colorT = colorIndex - Math.floor(colorIndex);

        const colorLow = p.color(params.colorScheme[colorIndexLow]);
        const colorHigh = p.color(params.colorScheme[colorIndexHigh]);
        const color = p.lerpColor(colorLow, colorHigh, colorT);

        // Calculate oscillating brush width
        const timeSincePointCreation = point.time - startTime;
        const brushWidth = p.map(
          p.sin(
            p.frameCount * params.globalSizeFrequency +
              params.sizeFrequency * timeSincePointCreation * 0.01
          ),
          -1,
          1,
          params.minBrushWidth,
          params.maxBrushWidth
        );

        // Calculate ripple effect
        const distFromCenter = p.dist(x, y, p.width / 2, p.height / 2);
        const ripple =
          p.sin(distFromCenter * params.rippleFrequency - rippleOffset) *
          params.rippleAmplitude;

        // Combine base width, oscillation, and ripple effect
        const currentBrushWidth = brushWidth + ripple;

        // Calculate rotation with wave
        const rotation =
          params.rotation +
          p.sin(
            p.frameCount * params.rotationRate +
              params.rotationWave * timeSincePointCreation * 0.01
          );

        // Calculate shape with wave
        const shapeValue = Math.max(
          1,
          Math.min(
            10,
            Math.floor(
              params.shape +
                p.sin(
                  p.frameCount * params.shapeRate +
                    params.shapeWave * timeSincePointCreation * 0.01
                )
            )
          )
        );

        // Calculate fill with wave and rate
        const fillValue =
          params.fill +
          p.sin(
            p.frameCount * params.fillRate +
              params.fillWave * timeSincePointCreation * 0.01
          );

        // Calculate opacity with wave and rate
        const opacity = p.map(
          p.sin(
            p.frameCount * params.opacityRate +
              params.opacityWave * timeSincePointCreation * 0.01 +
              Math.PI / 2
          ),
          -1,
          1,
          0,
          1
        );
        const finalOpacity = p.constrain(params.opacity * opacity, 0, 1);

        p.push();
        p.translate(x, y);
        p.rotate(rotation);

        // Apply opacity to the color
        const adjustedColor = p.color(color);
        adjustedColor.setAlpha(finalOpacity);

        const shapeSize = currentBrushWidth; // Use the same size for filled and unfilled shapes

        if (fillValue > 0.5) {
          p.fill(adjustedColor);
          p.noStroke();
        } else {
          p.noFill();
          p.stroke(adjustedColor);
          p.strokeWeight(1); // Fixed 1px stroke for unfilled shapes
        }

        if (shapeValue < 3) {
          // Draw a circle for 2 or fewer sides
          p.ellipse(0, 0, shapeSize * 2, shapeSize * 2);
        } else if (shapeValue === 4) {
          p.rect(-shapeSize, -shapeSize, shapeSize * 2, shapeSize * 2);
        } else {
          p.beginShape();
          for (let j = 0; j < shapeValue; j++) {
            const angle = j * ((2 * Math.PI) / shapeValue);
            const px = Math.cos(angle) * shapeSize;
            const py = Math.sin(angle) * shapeSize;
            p.vertex(px, py);
          }
          p.endShape(p.CLOSE);
        }

        p.pop();
      }

      p.pop();
    }

    p.windowResized = () => {
      const container = document.getElementById("sketch-container");
      p.resizeCanvas(container!.clientWidth, container!.clientHeight);
    };
  };

  new p5(sketch, document.getElementById("sketch-container") as HTMLElement);

  // Add this to prevent touch events on the settings panel from reaching the canvas
  document.getElementById("settings-panel-container")?.addEventListener(
    "touchstart",
    (e) => {
      e.stopPropagation();
    },
    { passive: false }
  );
</script>
